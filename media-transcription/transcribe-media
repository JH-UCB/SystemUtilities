#!/usr/bin/env bash
# transcribe-media — batch transcribe audio/video on macOS using whisper-cli/whisper-cpp
#
# usage:
#   transcribe-media [options] <file-or-dir> [more files/dirs...]
#
# common examples:
#   transcribe-media *.mp4
#   transcribe-media /path/to/folder
#   transcribe-media --recursive /path/to/folder
#   transcribe-media --outdir ~/Transcripts /path/to/folder
#   transcribe-media --lang en --model large-v3-turbo *.mov
#
# options:
#   --model {large-v3|large-v3-turbo|base|small|medium}   (default: large-v3)
#   --model-file <PATH>    use an explicit ggml model file path instead of auto-resolve
#   --lang <code|auto>     e.g., en, es, fr; default: auto
#   --threads <N>          cpu threads (default: all cores)
#   --sidecar              write outputs next to each media (default)
#   --outdir <DIR>         centralize all outputs in DIR (disables --sidecar)
#   --recursive            when a directory is provided, recurse into subfolders
#   --ext "mp4,mov,mkv,mp3,wav,flac,aac,m4a,ogg,webm"  (set recognized extensions)
#   --cpu-only             force cpu (no gpu)
#   --keep-audio           keep extracted .wav files
#   --help                 show help
#
# prerequisites:
#   brew install ffmpeg whisper-cpp   # (installs 'whisper-cli')

set -euo pipefail

# ---- helpers ----
msg()  { printf "\033[1;34m[transcribe]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
err()  { printf "\033[1;31m[error]\033[0m %s\n" "$*" >&2; }
have() { command -v "$1" >/dev/null 2>&1; }

print_help() { sed -n '2,50p' "$0" | sed 's/^# \{0,1\}//'; }

# ---- defaults ----
MODEL_SIZE="large-v3"
MODEL_FILE_OVERRIDE=""
LANG="auto"
THREADS="$(sysctl -n hw.ncpu 2>/dev/null || echo 8)"

SIDECAR=1              # default: outputs next to media
CENTRAL_OUTDIR=""      # set by --outdir to disable sidecar

RECURSIVE=0
EXTENSIONS="mp4,mov,mkv,mp3,wav,flac,aac,m4a,ogg,webm"
KEEP_AUDIO="0"
CPU_ONLY="0"

# ---- parse args ----
ARGS=()
while (( "$#" )); do
  case "$1" in
    --model)       shift; [ $# -gt 0 ] || { err "--model requires value"; exit 1; }; MODEL_SIZE="$1" ;;
    --model-file)  shift; [ $# -gt 0 ] || { err "--model-file requires path"; exit 1; }; MODEL_FILE_OVERRIDE="$1" ;;
    --lang)        shift; [ $# -gt 0 ] || { err "--lang requires value";  exit 1; }; LANG="$1" ;;
    --threads)     shift; [ $# -gt 0 ] || { err "--threads requires value"; exit 1; }; THREADS="$1" ;;
    --sidecar)     SIDECAR=1; CENTRAL_OUTDIR="" ;;
    --outdir)      shift; [ $# -gt 0 ] || { err "--outdir requires dir"; exit 1; }; CENTRAL_OUTDIR="$1"; SIDECAR=0 ;;
    --recursive)   RECURSIVE=1 ;;
    --ext)         shift; [ $# -gt 0 ] || { err "--ext requires comma list"; exit 1; }; EXTENSIONS="$1" ;;
    --cpu-only)    CPU_ONLY="1" ;;
    --keep-audio)  KEEP_AUDIO="1" ;;
    --help|-h)     print_help; exit 0 ;;
    -*)            err "unknown option: $1"; exit 1 ;;
    *)             ARGS+=("$1") ;;
  esac
  shift || true
done
[ ${#ARGS[@]} -gt 0 ] || { err "no inputs provided (files or directories)"; exit 1; }

# ---- deps ----
have ffmpeg || { err "ffmpeg not found; install: brew install ffmpeg"; exit 1; }
WHISPER_BIN=""
if have whisper-cli; then
  WHISPER_BIN="whisper-cli"
elif have whisper-cpp; then
  WHISPER_BIN="whisper-cpp"   # brew shim -> whisper-cli
else
  err "whisper-cli/whisper-cpp not found; install: brew install whisper-cpp"; exit 1
fi

# ---- collect media files from args (files and/or directories) ----
FILES=()

# build a find expression from comma-separated EXTENSIONS
build_find() {
  local dir="$1"
  local depth_opt="-maxdepth 1"
  [ "$RECURSIVE" = "1" ] && depth_opt=""

  local expr=""
  IFS=',' read -r -a exts <<<"$EXTENSIONS"
  for ext in "${exts[@]}"; do
    ext_trimmed="$(printf "%s" "$ext" | awk '{$1=$1};1')"
    [ -z "$expr" ] && expr="-iname *.$ext_trimmed" || expr="$expr -o -iname *.$ext_trimmed"
  done

  # shellcheck disable=SC2086
  find "$dir" $depth_opt -type f \( $expr \) -print0
}

for IN in "${ARGS[@]}"; do
  if [ -d "$IN" ]; then
    while IFS= read -r -d '' f; do FILES+=("$f"); done < <(build_find "$IN")
  elif [ -f "$IN" ]; then
    FILES+=("$IN")
  else
    warn "skipping non-existent input: $IN"
  fi
done

[ ${#FILES[@]} -gt 0 ] || { err "no matching media files found (exts: $EXTENSIONS)"; exit 1; }

# ---- model resolution ----
# map model size -> model filename
case "$MODEL_SIZE" in
  large-v3)        MODEL_FILE_NAME="ggml-large-v3.bin" ;;
  large-v3-turbo)  MODEL_FILE_NAME="ggml-large-v3-turbo.bin" ;;
  base)            MODEL_FILE_NAME="ggml-base.bin" ;;
  small)           MODEL_FILE_NAME="ggml-small.bin" ;;
  medium)          MODEL_FILE_NAME="ggml-medium.bin" ;;
  *)               warn "unknown model '$MODEL_SIZE'; using large-v3"; MODEL_FILE_NAME="ggml-large-v3.bin" ;;
esac

# choose model path
MODEL_PATH=""
if [ -n "$MODEL_FILE_OVERRIDE" ]; then
  MODEL_PATH="$MODEL_FILE_OVERRIDE"
else
  # prefer cache dir; fall back to cwd if already present there
  CACHE_DIR="$HOME/.cache/whisper.cpp/models"
  mkdir -p "$CACHE_DIR"
  if [ -f "./$MODEL_FILE_NAME" ]; then
    MODEL_PATH="./$MODEL_FILE_NAME"
  else
    MODEL_PATH="$CACHE_DIR/$MODEL_FILE_NAME"
  fi
fi

# download if missing
if [ ! -f "$MODEL_PATH" ]; then
  msg "downloading model $(basename "$MODEL_PATH") ..."
  curl -L --fail --retry 3 -C - -o "$MODEL_PATH" \
    "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/${MODEL_FILE_NAME}" \
    || { err "failed to download model"; exit 1; }
fi

# ---- output setup ----
if [ "$SIDECAR" = "0" ]; then
  mkdir -p "$CENTRAL_OUTDIR"
fi

# temp workspace
TMPROOT="$(mktemp -d -t transcribe-XXXXXXXX)" || { err "mktemp failed"; exit 1; }
trap 'rm -rf "$TMPROOT"' EXIT

TOTAL=${#FILES[@]}
INDEX=0

# detect offload style (cli flag differences)
HELP_OUT="$("$WHISPER_BIN" --help 2>&1 || true)"
if echo "$HELP_OUT" | grep -q -- '-ngl'; then
  OFFLOAD_STYLE="ngl"        # legacy main supports -ngl N
elif echo "$HELP_OUT" | grep -q -- '--no-gpu'; then
  OFFLOAD_STYLE="nogpu"      # whisper-cli supports -ng / --no-gpu
elif echo "$HELP_OUT" | grep -q -E '\s-ng(\s|,|$)'; then
  OFFLOAD_STYLE="nogpu"
else
  OFFLOAD_STYLE="none"
fi

# predeclare to satisfy 'set -u'
OFFLOAD_FLAGS=()

# ---- main loop ----
for INPUT in "${FILES[@]}"; do
  INDEX=$((INDEX+1))
  [ -f "$INPUT" ] || { warn "not found: $INPUT — skipping"; continue; }

  dir="$(dirname "$INPUT")"
  base="$(basename "$INPUT")"
  stem="${base%.*}"

  # decide output prefix
  if [ "$SIDECAR" = "1" ]; then
    OUT_PREFIX="${dir}/${stem}"
  else
    OUT_PREFIX="${CENTRAL_OUTDIR%/}/${stem}"
  fi

  # extract to mono/16k wav for stable decoding
  WAV="$TMPROOT/$stem.wav"
  msg "[$INDEX/$TOTAL] extracting audio: $INPUT"
  if ! ffmpeg -y -i "$INPUT" -vn -ac 1 -ar 16000 -c:a pcm_s16le "$WAV" >/dev/null 2>&1; then
    warn "ffmpeg failed for '$INPUT' — skipping"
    continue
  fi

  # build offload flags (gpu is default; only set flags for cpu-only)
  OFFLOAD_FLAGS=()
  if [ "$CPU_ONLY" = "1" ]; then
    if [ "$OFFLOAD_STYLE" = "ngl" ]; then
      OFFLOAD_FLAGS=( -ngl 0 )
    elif [ "$OFFLOAD_STYLE" = "nogpu" ]; then
      OFFLOAD_FLAGS=( -ng )
    fi
  fi

  msg "[$INDEX/$TOTAL] transcribing → ${OUT_PREFIX}.{txt,srt}"
  if ! "$WHISPER_BIN" \
        -m "$MODEL_PATH" \
        -f "$WAV" \
        -l "$LANG" \
        -t "$THREADS" \
        "${OFFLOAD_FLAGS[@]:-}" \
        -otxt -osrt \
        -pp \
        -of "$OUT_PREFIX" >/dev/null 2>&1; then
    warn "whisper failed for '$INPUT' — skipping"
    continue
  fi

  if [ -f "${OUT_PREFIX}.txt" ] && [ -f "${OUT_PREFIX}.srt" ]; then
    [ "$KEEP_AUDIO" = "1" ] && cp "$WAV" "${OUT_PREFIX}.wav"
    msg "[$INDEX/$TOTAL] done: ${OUT_PREFIX}.txt  |  ${OUT_PREFIX}.srt"
  else
    warn "no transcript files produced for '$INPUT' — check cli output"
  fi
done

msg "all done."

